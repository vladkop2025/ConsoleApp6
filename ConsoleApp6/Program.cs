using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp6
{
    internal class Program
    {
        static void Main(string[] args)
        {
            //Модуль 6.ООП.Введение
            /* 6.4. Упаковка и распаковка
             При работе со значимыми типами вы можете столкнуться с такими процессами, как упаковка (boxing) и распаковка (unboxing).

                Упаковка — процесс преобразования объекта значимого типа в объект типа object. При этом значение объекта заносится в управляемую кучу.

                Распаковка — обратный упаковке процесс, когда из упакованного объекта типа object создается объект изначального типа. 
                При этом значение объекта переносится из управляемой кучи в стек. 

            Упаковка может быть использована для решения проблем разнотипных объектов. Например, если вы захотите хранить в одном массиве 
            и целочисленные значения типа int, и строки типа string, то вы можете создать массив объектов object[].

            Вы уже сталкивались с упаковкой, например, когда использовали метод Console.WriteLine(). Данный метод в качестве параметров 
            принимает строку string и массив объектов object[]. Поскольку мы передаем в метод и значимые типы, они упаковываются в тип 
            object и после этого используются методом.

            Процесс упаковки выглядит следующим образом:

                    int i = 123;
                    // Упаковка значения i в объект o
                    object o = i;
            При создании переменной i мы создаем объект значимого типа и храним его значение (123) в стеке. Как только вы присваиваете 
            его переменной o, значение переменной i копируется в кучу вместе с указанием изначального типа. Затем в стек заносится ссылка на значение в куче.

            Также возможно производить и явную упаковку:

                    object o = (object)i;

            Распаковка же происходит только явным образом:

                    int i = 123;
                    // Упаковка значения i в объект o
                    object o = i;
                    // Распаковка o
                    int j = (int)o;

            После упаковки переменную o можно распаковать в j, тем самым скопировав данные из кучи в стек.

            Упаковка и распаковка ресурсозатратны, поскольку требуют выделения памяти и приведения типов. Поэтому данных операций 
            стараются избегать, когда это возможно. Одним из инструментов, который позволяет это делать являются обобщения 
            (или обобщенные типы, Generic-типы), о которых мы поговорим в следующем модуле.

            Целесообразность оптимизации появляется, как правило, тогда, когда операции упаковки и распаковки предстоит 
            производить в цикле сотни и тысячи раз. В ином случае не стоит бояться падения производительности, поскольку оно не будет ощутимым.

            Задание 6.4.1
            Выберите верные утверждения:

                2. Упаковка производится для значимых типов
                4. Упаковка позволяет преобразовать экземпляр значимого типа в экземпляр типа object

            Задание 6.4.2   
            Выберите верные утверждения:

                1. Упаковка может производиться явным образом
                2. Упаковка может производиться неявным образом
                3. Распаковка может производиться явным образом
            */
        }
    }
}
