using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp6
{
    internal class Program
    {
        static void Main(string[] args)
        {
            //Модуль 6.ООП.Введение
            /********************************
             * 6.4. Упаковка и распаковка
             ******************************** 
             При работе со значимыми типами вы можете столкнуться с такими процессами, как упаковка (boxing) и распаковка (unboxing).

                Упаковка — процесс преобразования объекта значимого типа в объект типа object. При этом значение объекта заносится в управляемую кучу.

                Распаковка — обратный упаковке процесс, когда из упакованного объекта типа object создается объект изначального типа. 
                При этом значение объекта переносится из управляемой кучи в стек. 

            Упаковка может быть использована для решения проблем разнотипных объектов. Например, если вы захотите хранить в одном массиве 
            и целочисленные значения типа int, и строки типа string, то вы можете создать массив объектов object[].

            Вы уже сталкивались с упаковкой, например, когда использовали метод Console.WriteLine(). Данный метод в качестве параметров 
            принимает строку string и массив объектов object[]. Поскольку мы передаем в метод и значимые типы, они упаковываются в тип 
            object и после этого используются методом.

            Процесс упаковки выглядит следующим образом:

                    int i = 123;
                    // Упаковка значения i в объект o
                    object o = i;
            При создании переменной i мы создаем объект значимого типа и храним его значение (123) в стеке. Как только вы присваиваете 
            его переменной o, значение переменной i копируется в кучу вместе с указанием изначального типа. Затем в стек заносится ссылка на значение в куче.

            Также возможно производить и явную упаковку:

                    object o = (object)i;

            Распаковка же происходит только явным образом:

                    int i = 123;
                    // Упаковка значения i в объект o
                    object o = i;
                    // Распаковка o
                    int j = (int)o;

            После упаковки переменную o можно распаковать в j, тем самым скопировав данные из кучи в стек.

            Упаковка и распаковка ресурсозатратны, поскольку требуют выделения памяти и приведения типов. Поэтому данных операций 
            стараются избегать, когда это возможно. Одним из инструментов, который позволяет это делать являются обобщения 
            (или обобщенные типы, Generic-типы), о которых мы поговорим в следующем модуле.

            Целесообразность оптимизации появляется, как правило, тогда, когда операции упаковки и распаковки предстоит 
            производить в цикле сотни и тысячи раз. В ином случае не стоит бояться падения производительности, поскольку оно не будет ощутимым.

            Задание 6.4.1
            Выберите верные утверждения:

                2. Упаковка производится для значимых типов
                4. Упаковка позволяет преобразовать экземпляр значимого типа в экземпляр типа object

            Задание 6.4.2   
            Выберите верные утверждения:

                1. Упаковка может производиться явным образом
                2. Упаковка может производиться неявным образом
                3. Распаковка может производиться явным образом

            ********************************
            * 6.5. Введение в ООП
            ******************************** 
             
            ООП — объектно-ориентированное программирование.

            Объект — это некоторый элемент реального мира в цифровом представлении (в программе), 
            обладающий индивидуальными/характерными свойствами.

            Класс — это набор объектов, обладающих общими характерными свойствами, которые однозначно 
            идентифицируют эту группу объектов.

            В терминологии C# класс — это класс, а в качестве объекта выступает экземпляр класса.

            -------------------------------
            Абстракция
            -------------------------------

            Наряду с полиморфизмом наследованием и инкапсуляцией ООП располагает ещё одним очень важным инструментом — абстракцией.

            Абстрагирование — это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. 
            Соответственно, абстракция — это использование всех таких характеристик для описания объекта.

            Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной 
            точностью для решаемой задачи.

Абстракция позволяет работать с объектами, не вдаваясь в особенности их реализации. Подробнее о реализации абстракции в C# 
            мы поговорим в следующем модуле.

            Задание 6.5.1  
            Соедините термины и их значения.

                Ответ: Класс Объект Абсрагирование

            Задание 6.5.2
            Опишите классы C# для следующих геометрических объектов: треугольник, круг, квадрат.

            Не забывайте, что для получения площади круга и длины окружности нужно производить умножение на 3,14. Поэтому полученное значение будет иметь тип double.

class Circle
{
	public double radius;

	public double Square()
	{
	}

	public double Length()
	{
	}
}

class Triangle
{
	public int a;
	public int b;
	public int c;

	public double Square()
	{
	}

	public double Perimeter()
	{
	}
}

class Square
{
	public int side;

	public double Square()
	{
	}

	public double Perimeter()
	{
	}
}
            ********************************
            * 6.6. Инкапсуляция
            ******************************** 

            Инкапсуляция — это объединение и изолирование всех данных и процессов объекта внутри единой структуры.

            -------------------------------
            Библиотека классов
            -------------------------------

                Библиотека классов — это определенный тип проектов в .Net, который позволяет переиспользовать свой код 
                в других приложениях в виде подключаемых модулей.

            Библиотека классов может использоваться и в качестве общего источника кода внутри одного проекта и служит 
            для разделения кодовой базы на определенные значимые части.

            Внутри библиотеки классов хранятся классы (ровно как и структуры), которые включают в себя определенную логику. 
            Например, это могут быть классы только для взаимодействия с хранилищем данных на проекте (база данных).

            Библиотека классов компилируется в сборку и уже в таком виде подключается к другим частям приложения при его работе.

                Сборка является базовой структурной единицей в .Net, на уровне которой проходит контроль версий, развертывание 
                и конфигурация приложения.

            При создании и подключении библиотеки классов мы имеем контекст определенной сборки — того проекта, в котором находится код. 
            И благодаря инструментам C# мы можем определять, какой код (классы и члены классов) может быть использован только внутри сборки,
            а какой будет доступен извне.

            -------------------------------
            Модификаторы доступа
            -------------------------------
            
            В видео упоминались приватные и публичные методы. В рамках же языка C# это слова public и private в объявлении методов 
            и полей (то самое ключевое слово public, которое позволило использовать переменные нашего класса извне). Эти ключевые 
            слова называются модификаторами доступа.

            В C# существуют следующие модификаторы доступа:

            
            public	Публичный общедоступный класс или член класса.
                    Элементы и классы, помеченные таким модификатором, доступны из любого места в коде, а также из других программ и сборок.

            private	Закрытый класс или член класса. Представляет полную противоположность модификатору public.
                    Элементы и классы, помеченные таким модификатором, доступны только из кода в том же классе или контексте.

            protected	Защищенный член класса. Используется при наследовании (одном из принципов ООП, о котором мы поговорим в следующем модуле).
                        Элементы, помеченные таким модификатором, доступны из любого места в текущем классе или в производных классах. 
                        При этом производные классы могут располагаться в других сборках.

            internal	Элементы и классы, помеченные таким модификатором, доступны из любого места кода в той же сборке, однако 
                        он недоступен для других программ и сборок (как в случае с модификатором public).
            
            protected internal	Данный модификатор совмещает функционал двух модификаторов protected и internal.
                                Элементы и классы, помеченные таким модификатором, доступны в текущей сборке и из производных классов 
                                (при наследовании), даже если производные классы располагаются в других сборках.

            private protected	Данный модификатор совмещает функционал двух модификаторов private и protected.
                                Элементы, помеченные таким модификатором, доступны из любого места в текущем классе или 
                                в производных классах, которые определены в той же сборке.

            Рассмотрим на примере работу с public и private модификаторами. Продолжим работу с классом Car, подразумевая, что процессы 
            происходящие внутри машины — приватные и не нужны для внешнего мира, а иные процессы — публичные.

            Таким образом, мы можем изменить класс Car:

enum TurnDirection
{
	None = 0,
	Left,
	Right
}

class Car
{
	private double Fuel;

	private int Mileage;

	private string color;

	private TurnDirection turn;

	public Car()
	{
		Fuel = 50;
		Mileage = 0;
		color = "White";
	}

	private void Move()
	{
		// Move a kilometer
		Mileage++;
		Fuel -= 0.5;
	}

	private void Turn(TurnDirection direction)
	{
		turn = direction;
	}

	public void FillTheCar()
	{
		Fuel = 50;
	}

	public string GetColor()
	{
		return color;
	}

	public void ChangeColor(string newColor)
	{
		if (color != newColor)
			color = newColor;
	}

	public bool IsTurningLeft()
	{
		return turn == TurnDirection.Left;
	}

	public bool IsTurningRight()
	{
		return turn == TurnDirection.Right;
	}
}

            Для начала мы добавили перечисление TurnDirection для обозначения направления поворота для указателя поворота 
            машины (поворотник не включен, право, лево). Вместе с ним мы добавили закрытое поле для хранения этой информации 
            и закрытый метод для изменения его значения, чтобы водитель мог включать и выключать поворотники.

            Для внешнего же мира мы должны получать информацию о том, поворачивает ли машина вправо или влево — методы 
            IsTurningRight и IsTurningLeft.

            Также машине был добавлен цвет, используя приватное поле color. И два метода: для получения цвета машины 
            (мы же можем посмотреть на нее и определить цвет визуально) и для смены цвета (если мы захотим перекрасить машину).

            Помимо этого уже существовавшие поля мы сделали закрытыми, как и метод Move().

            Таким образом, мы добавили машине некоторые функции и разграничили их использование вне её.

            Задание 6.6.1
            Напишите класс светофор (TrafficLight) с 2 методами:

            Закрытый метод ChangeColor, принимающий 1 строковый параметр color.
            Открытый метод GetColor, который не принимает параметры, но выдает строковое значение цвета.
            Методы реализовывать не нужно

class TrafficLight
{
	private void ChangeColor(string color)
	{

	}

	public string GetColor()
	{

	}
}
            -------------------------------
            Свойства
             -------------------------------
            
            Помимо методов и полей в классах язык C# предусматривает использование специальных элементов, 
            находящихся где-то между. Они называются свойства.

                    Свойства являются специальными членами классов (и структур), которые позволяют получать и изменять значение 
                    приватного поля, применяя некоторую логику для проверки (валидации) действий.

            По своему синтаксису свойства похожи на методы без входных параметров и скобок для них. Рассмотрим на примере:

class User
{
	private int age;

	public int Age
	{
		get
		{
			return age;
		}

		set
		{
			age = value;
		}
	}
}

            В данном случае публичным свойством является public int Age, которое работает с приватным полем. 
            Специальные конструкции: get {} — геттер и set {} — сеттер работают при обращении для чтения и записи в поле. 
            Параметр value представляет передаваемое значение.

class Program
{
	static void Main(string[] args)
	{
		User user = new User();

		// Setter
		user.Age = 23;

		// Getter
		Console.WriteLine(user.Age);

		Console.ReadKey();
	}
}

            Через данное свойство мы можем управлять доступом к переменной age вне класса. Когда мы обращаемся к полю 
            для чтения его значения, то попадаем в выполнение блока кода в get {}, а когда устанавливаем значение в поле — блока set {}.

            Что такого особенного в свойствах, для чего их стоит использовать вместо полей? С помощью полей можно вложить 
            дополнительную логику, которая может быть необходима при присвоении переменной класса какого-либо значения или чтении из нее.

            Самый простой пример — валидация данных, к примеру возраста:

class User
{
	private int age;

	public int Age
	{
		get
		{
			return age;
		}

		set
		{
			if (value < 18)
			{
				Console.WriteLine("Возраст должен быть не меньше 18");
			}
			else
			{
				age = value;
			}
		}
	}
}

            В таком случае мы не сможем вносить возраст меньше 18 лет для пользователя, и данная логика проверки 
            будет храниться в непосредственной близости к данным (если делать такую проверку каждый раз, когда вы 
            используете поле, то может быть много одинакового кода, а еще страшнее, если вам придется поменять эту логику, 
            и вы можете ошибиться в одной из таких проверок или пропустить её).

            Важно понимать, что логика работы в свойствах не должна выполнять какие-то несвязанные с полем операции.
            Например, при изменении возраста вы не должны менять логин пользователя или его аватар. Если же такая логика 
            требуется, то её лучше выполнять в методах, чтобы не путать данные с операциями.

            Задание 6.6.2
            Добавьте в класс User из примера выше свойства для логина и почты:

            Поле логина должно быть не менее 3 символов длиной.
            Поле почты должно содержать знак @.
            О том, как узнать длину строки и содержит ли она определенный символ, постарайтесь найти информацию сами. 
            Если же у вас не получается — смотрите подсказк

            Для длины строки используется ее свойство Length, а для проверки символа — метод Contains().

class User
{
	private string login;

	public string Login
	{
		get
		{
			return login;
		}

		set
		{
			if (value.Length < 3)
			{
				Console.WriteLine("Логин должен быть длиной от 3 символов");
			}
			else
			{
				login = value;
			}
		}
	}

	private string email;

	public string Email
	{
		get
		{
			return email;
		}

		set
		{
			if (!value.Contains('@'))
			{
				Console.WriteLine("Неверный формат адреса электронной почты");
			}
			else
			{
				email = value;
			}
		}
	}
}
            -------------------------------
            Свойства только для чтения и только для записи
            -------------------------------

            Блоки set и get необязательно одновременно должны присутствовать в свойстве. Если свойство определяет 
            только блок get, то такое свойство доступно только для чтения — мы можем получить его значение, но не установить. 
            И наоборот, если свойство имеет только блок set, тогда это свойство доступно только для записи — можно только 
            установить значение, но нельзя получить:

class User
{
	private string login;
	private DateTime lastSeen;

	// Read-only
	public string Login
	{
		get
		{
			return login;
		}
	}

	// Write-only
	public DateTime LastSeen
	{
		set
		{
			lastSeen = value;
		}
	}
}

            В данном примере свойства логин и последнее время посещения являются свойствами только для чтения 
            и только для записи соответственно.  Мы не даем возможность перезаписать логин извне и не даем 
            возможность прочитать, когда пользователь был онлайн извне, только записать эту дату.

            -------------------------------
            Модификаторы доступа
            -------------------------------
            
            Помимо всего прочего для сеттеров и геттеров может быть установлен модификатор доступа, 
            отличный от модификатора самого свойства:

class User
{
	private int age;

	public int Age
	{
		get
		{
			return age;
		}

		private set
		{
			age = value;
		}
	}
}

            Теперь приватный блок set можно использовать только в данном классе: в его методах, свойствах, 
            конструкторе, но никак не в другом классе:

            Важно соблюдать следующие правила:

                Модификатор для блока set или get можно установить, если свойство имеет оба блока (и set, и get).
                Только один из блоков set/get может иметь модификатор доступа, но не оба сразу.
                Модификатор доступа блока set/get должен быть более ограничивающим, чем модификатор доступа свойства. 
                Например, если свойство имеет модификатор public, то блок set/get может иметь только модификаторы, 
                с использованием которых блок будет менее доступен: protected internal, internal, protected, private

            -------------------------------
            Автоматические свойства
            -------------------------------

            C# позволяет сокращать запись свойств там, где не нужно использовать особую логику, но нужно управлять 
            доступом к полям. С помощью автоматических свойств можно писать свойства в 1 строку, не уступая по 
            объему объявлению полей:

            class User
{
	public string Login { get; set; }
	public int Age { get; set; }
}
            На самом деле тут также создаются поля для свойств, только их создает не программист в коде, а компилятор 
            автоматически генерирует при компиляции.

            Преимущество автосвойств в том, что в любой момент времени при необходимости мы можем развернуть автосвойство 
            в обычное свойство, добавить в него какую-то определенную логику.

            Несмотря на всю схожесть работы с обычными свойствами, нельзя создать автоматическое свойство только 
            для записи, как в случае со стандартными свойствами.

            Автосвойства также могут иметь модификаторы доступа:

class User
{
	public string Login { get; private set; }
	public int Age { private get; set; }
}

            Задание 6.6.3
            Какой модификатор доступа предполагает доступ к классу и элементам класса внутри одной и той же сборки?

                internal

            Задание 6.6.4
            Выберите вариант с верным заданием свойства PropertyName:

            public string PropertyName { private get; protected set; }
            private string PropertyName { get; protected set; }            
            public string PropertyName { protected get; }            
            public string PropertyName { private get; set; }           Ответ

            get: Доступен только внутри класса (private).
            set: Доступен везде, где доступно свойство (public).
            Корректность: Это допустимый синтаксис. Свойство можно читать только внутри класса, но устанавливать 
            его значение можно из любого места, где доступно свойство.

            ********************************
            * 6.7. Итоги
            ******************************** 

            Задание 1
            На какие 2 типа разделяется память?

                    стек
                    куча

            Задание 2
            Что такое null?

                    Специальное значение, которое означает отсутствие значения как такового в переменной/поле

            Задание 3
            Какие типы могут принимать null? Выберите правильный вариант ответа

                    Ссылочные типы и Nullable-типы

            Задание 4
            Можно ли произвести явную упаковку? А неявную распаковку?

                    Можно производить явную упаковку, но нельзя производить неявную распаковку

            Задание 5 
            Что такое класс в понятиях ОО

                    Набор объектов, обладающих общими характерными свойствами, которые однозначно идентифицируют эту группу объектов

            Задание 6
            Что такое объект в понятиях ООП?

                    Элемент реального мира в цифровом представлении, обладающий индивидуальными/характерными свойствами

            Задание 7
            Сопоставьте правильные варианты.

                    Абстрагирование - способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые

                    Инкапсуляция    - объединение и изолирование всех данных и процессов  объекта внутри единой структуры

            Задание 8
            Сколько существует модификаторов доступа?

                    7

            Задание 9
            Какой модификатор доступа имеет наибольшую допустимую область видимости для элементов?

                    public

            Задание 10 
            Какой модификатор доступа имеет наименьшую допустимую область видимости для элементов?

                    private

            Задание 11
            Что можно делать с автосвойствами?

                    Развернуть в обычные свойства
                    Добавить модификатор доступа
            */
        }
    }
}
