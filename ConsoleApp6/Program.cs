using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace ConsoleApp6
{
    internal class Program
    {
        static void Main(string[] args)
        {
            //Модуль 6.ООП.Введение
            /*****************************
             * 6.1. Ссылочные и значимые типы данных. Структуры и объекты
             *****************************
            6.2. Классы и структуры
            6.3. Особенности работы со ссылочными и значимыми типами данных
            */

            /*6.1. Ссылочные и значимые типы данных. Структуры и объекты ***************************************************
            Ранее вы познакомились с примитивными типами данных в C# (int, long, byte, char, string, object и другими), 
            а также с перечислениями enum. Помимо этих типов язык C# позволяет создавать свои типы данных, и в более
            широком понимании все возможные типы делятся на 2 категории: 

	            ссылочные (Reference-type) 
	            значимые (Value-type или типы значений).

            -------------------------------------
            Value-Type
            -------------------------------------
            Типы с плавающей запятой float, double
            decimal
            bool
            char
            Перечисления enum
            Структуры struct

            -------------------------------------
            Reference-Type
            -------------------------------------
            object
            string
            Массивы System.Array (int[], bool[], ...)
            Классы class
            Интерфейсы* interface
            Делегаты* delegate

            В .Net память делят на 2 типа: стек (Stack) и куча (Heap или управляемая куча).

            В стеке .Net такими элементами являются фреймы — блоки памяти, выделяемые специально для метода. И очистка 
            этой памяти производится, когда метод завершает свою работу и происходит выход из метода.

            В отличие от стека, куча не имеет какой-то структуры и объекты в ней не располагаются особым образом и не 
            привязаны к порядку вызова методов, а значит, и очистки памяти при выходе не производится. Этим уже 
            занимается Garbage Collector, о его работе чуть больше вы можете узнать здесь

                Значимый тип — тип, значение которого хранится в стеке.
                Ссылочный тип — тип, значение которого хранится в куче, а в стеке хранится ссылка на адрес в куче.

                    Таким образом, следует быть осторожным с копированием ссылочных типов и помнить о том, что копируется 
                    лишь ссылка на объект в куче, чтобы не произошла ошибка при изменении значения.

            Задание 6.1.1
               Ссылочный тип - object, string
               Значимые типы - int, long, byte, double, decimal, char, bool, enum
            */

            /*****************************
             * 6.2.Классы и структуры 
             *****************************
             
            При объявлении класса или структуры следует сначала написать ключевое слово class или struct, затем наименование 
            класса (или структуры) и уже в фигурных скобках определять внутренние элементы. 

    class Human
    {
        // Поля класса
        public string name;
        public int age;

        // Метод класса
        public void Greetings()
        {
            Console.WriteLine("Меня зовут {0}, мне {1}", name, age);
        }
    }

    struct Animal
    {
        // Поля структуры
        public string type;
        public string name;
        public int age;

        // Метод структуры
        public void Info()
        {
            Console.WriteLine("Это {0} по кличке {1}, ему {2}", type, name, age);
        }
    }

            При объявлении класса или структуры следует сначала написать ключевое слово class или struct, 
            затем наименование класса (или структуры) и уже в фигурных скобках определять внутренние элементы.
            
            возраста человека, а также метод Greetings, который представляет этого человека. В данном методе 
            используются значения переменных name и age, поскольку мы имеем доступ к полям класса внутри объектов 
            этого же класса. Ключевое слово public позволяет получать доступ к полям и методам вне данного 
            класса (подробнее об этом поговорим позже).

            Аналогично объявляем структуру Animal с полями type для типа животного (кот, собака, хомяк и т.д.),  
            name для клички и age для возраста.

            Для использования классов и структур в коде их следует использовать как типы переменных, обращаясь 
            к ним по имени. То есть созданный выше класс Human мы можем использовать как тип переменной:

                        Human human;

                    Используя классы и структуры в качестве типов данных, вы можете создавать свои объекты, включающие 
                    указанные поля — экземпляры классов и структур (то, что будет содержаться в переменной).

            Задание 6.2.1 Выберите корректный вариант объявления класса:


class Example
{
	public string Name;

	public void Show()
	{

	}
}

            Расположение классов - В C# возможно определять классы (и структуры) как в пространстве имен, так и внутри других классов:

namespace FirstApp
{
	class ExternalClass
	{
		public class ClassInternalClass
		{
		}

		struct ClassInternalStruct
		{
		}
	}

	class ExternalStruct
	{
		class StructInternalClass
		{
		}

		public struct StructInternalStruct
		{
		}
	}
}

            Внутренние классы и структуры помеченные ключевым словом public, аналогично полям и методам, 
            будут доступны вне используемого класса. Но только с указанием родительского класса перед наименованием используемого класса.

            Например, вот так:

class Program 
{
	static void Main(string[] args) 
        {

		ExternalClass.ClassInternalClass newClass;
		ExternalStruct.StructInternalStruct newStruct;
	}
}

            Конструкторы

            Конструктор — специальный метод, имеющий одно название с классом (структурой), который вызывается при 
            создании нового объекта данного класса (структуры).

            Конструкторы выполняют инициализацию объекта.

            Если в классе (структуре) не определен ни один конструктор, то для него автоматически создаётся 
            конструктор по умолчанию. Такой конструктор не имеет параметров и не имеет тела.

            Для класса действует правило: если в классе определен хотя бы 1 конструктор, то конструктор по умолчанию не будет создан.

                Но для структуры конструктор по умолчанию будет создаваться всегда, поэтому в структуру нельзя добавить конструктор без параметров.
            
            Инициализация переменной human с использованием конструктора будет выглядеть следующим образом:

                    Human human = new Human();

            Оператор new выделяет память для объекта Human. И затем вызывается конструктор по умолчанию, который не принимает 
            никаких параметров. В итоге после выполнения данного выражения в памяти будет выделен участок, где будут храниться 
            все данные объекта Human. А переменная human получит ссылку на созданный объект.

            Если конструктор не инициализирует значения полей объекта, то они получают значения по умолчанию. Для переменных 
            числовых типов это число 0, а для типа string и классов — это значение null (то есть фактически отсутствие значения).

            Проверим это на следующем примере:

namespace FirstApp
{
	class Human
	{
		// Поля класса
		public string name;
		public int age;

		// Метод класса
		public void Greetings()
		{
			Console.WriteLine("Меня зовут {0}, мне {1}", name, age);
		}
	}

	struct Animal
	{
		// Поля структуры
		public string type;
		public string name;
		public int age;

		// Метод структуры
		public void Info()
		{
			Console.WriteLine("Это {0} по кличке {1}, ему {2}", type, name, age);
		}
	}

	class Program
	{
		static void Main(string[] args)
		{
			Human human = new Human();
			human.Greetings();

			human.name = "Дмитрий";
			human.age = 23;
			human.Greetings();


			Console.ReadKey();
		}
	}
}

            Создание конструкторов

            Помимо конструктора по умолчанию пользователь может создавать свои конструкторы. Как уже говорилось ранее, 
            конструктор — это метод, который имеет одно название с классом (структурой), для которого он определен. 
            Определим несколько конструкторов для класса Human:

class Human
{
	// Поля класса
	public string name;
	public int age;

	// Метод класса
	public void Greetings()
	{
		Console.WriteLine("Меня зовут {0}, мне {1}", name, age);
	}

	// Конструктор 1
	public Human()
	{
		name = "Неизвестно";
		age = 20;
	}
	// Конструктор 2
	public Human(string n)
	{
		name = n;
		age = 20;
	}
	// Конструктор 3
	public Human(string n, int a)
	{
		name = n;
		age = a;
	}
}

            Мы создали 3 конструктора:

                    Human() — конструктор без параметров;
                    Human(string n) — конструктор с 1 параметром для того, чтобы присвоить имя;
                    Human(string n, int a) — конструктор с 2 параметрами для имени и возраста.

            Рассмотрим работу данных конструкторов:

class Program {
	static void Main(string[] args)         {
		Human human = new Human();
		human.Greetings();

		human = new Human("Дмитрий");
		human.Greetings();

		human = new Human("Дмитрий", 23);
		human.Greetings();

		Console.ReadKey();
	}
}

            В конструкторе класса мы можем не инициализировать все поля. Например, мы можем оставить поле age неинициализированным, 
            и оно будет заполнено значением по умолчанию 0:

public Human(string n)
{
	name = n;
}

            Но если попробовать сделать так с конструктором структуры, мы получим ошибку
            Таким образом, в конструкторах структур нужно инициализировать все поля данной структуры.

            Задание 6.2.2
            Добавьте в класс Pen, указанный ниже, 2 конструктора:
                без параметров, когда поля color и cost заполняются значениями Черный и 100.
                с 2 параметрами: penColor и penCost.

public Pen()
{
	color = "Черный";
	cost = 100;
}

public Pen(string penColor, int penCost)
{
	color = penColor;
	cost = penCost;
}

            Инициализаторы
            Помимо явного вызова конструкторов для инициализации объектов можно воспользоваться инициализаторами.

            Инициализаторы представляют передачу в фигурных скобках значений доступным полям и свойствам объекта.
            Например, при выполнении следующего кода:

                    Human human = new Human { name = "Дмитрий", age = 23 };
                    human.Greetings();

            В консоль будет выведено сообщение:  Меня зовут Дмитрий, мне 23. Таким образом, при создании объекта 
            неявно будет вызван конструктор, и после этого поля name и age будут заполнены значениями.

            Важно отметить:

                С помощью инициализатора можно устанавливать значения только доступных из внешнего кода полей и 
                свойств объекта (которые помечены ключевым словом public).

                Если в конструкторе устанавливаются значения полей, которые указаны в инициализаторе, то значения, 
                устанавливаемые в конструкторе, заменяются значениями из инициализатора.

            Задание 6.2.3
            Для структуры Animal напишите выражение для создания экземпляра с инициализатором, заполнив поля type значением 
            "Собака", name — "Вольт", age — 4. Поля обязательно должны быть в таком же порядке.
            Выражение для ответа должно находиться в правой части присвоения, то есть вместо знаков ??? в выражении Animal animal = ??? .

                    new Animal{type = "Собака", name = "Вольт", age = 4}; 

            Назначение структур
            
            Как вы уже поняли, по представленному функционалу структуры и классы не так уж сильно и отличаются. 
            Однако, отличия будут вскрываться далее, при погружении в ООП.

            Структуры работают быстрее из-за различия в хранении данных (вам не нужно переходить по ссылке в кучу, значение 
            уже хранится в стеке). Но они очень узконаправлены, и использовать их стоит, когда экземпляры структуры малы, 
            недолго «живут» и часто используются внутри других типов.

            Если тип имеет не все нижеприведенные характеристики, Microsoft не советует пользоваться структурой:

                Тип представляет одно простое значение, схожее с примитивными типами.
                Размер экземпляра не более 16 байт.
                Значение неизменяемо.
            
            Тип будет часто упаковываться (об упаковке читайте в следующем юните).

            Задание 6.2.4
            Выберите верное утверждение:

                Классы и структуры могут располагаться в пространствах имен и внутри других классов и структур

            Задание 6.2.5 
            Выберите верное утверждение:

                Структуры являются значимыми типами

            Задание 6.2.6
            Когда будет создан конструктор по умолчанию?

                Когда в классе не определен ни один конструктор
            
            Задание 6.2.7
            Выберите верный вариант инициализации экземпляра следующей структуры:

                Animal animal = new Animal { type = "Кот", name = "Барсик", age = 3 };

            Задание 6.2.8
            Создайте класс Rectangle для представления прямоугольников удовлетворяющий следующим требованиям:

                Класс должен содержать целочисленные поля для сторон a и b.
                Класс должен содержать метод Square, возвращающий площадь прямоугольника (произведение сторон).
                Класс должен содержать 3 конструктора: с 2 параметрами, когда a != b, с 1 параметром, когда a == b, 
                и конструктор без параметров по умолчанию, в котором стороны будут заполняться как a = 6, b = 4.

        }
        class Rectangle
        {
            public int a;
            public int b;

            public Rectangle()
            {
                a = 6;
                b = 4;
            }

            public Rectangle(int side)
            {
                a = side;
                b = side;
            }

            public Rectangle(int first, int second)
            {
                a = first;
                b = second;
            }

            public int Square()
            {
                return a * b;
            }
        }
            */

            /*****************************
             * 6.3. Особенности работы со ссылочными и значимыми типами данных 
             *****************************
            Прежде всего, стоит разобрать поведение при присваивании переменных ссылочных и значимых типов.
            Заведем структуру Data и класс Obj с некоторыми полями. После этого проинициализируем их и проверим их поведение в отладчике:

            Вернемся к передаче параметров в метод. Как вы узнали из предыдущего модуля, передавать в метод параметры можно двумя способами: 
            по значению и по ссылке (с использованием ключевых слов in, out, ref).

            При передаче параметров по значению в фрейме метода выделяется память для переданного параметра.

            Если передаваемый параметр является значимым типом, его значение записывается в выделенную память и используется, 
            пока не будет произведен выход из метода.
            Если передаваемый параметр является ссылочным типом, в выделенную память записывается ссылка на объект в куче.
            Однако, если передавать параметр по ссылке, мы не записываем ни новую ссылку, ни значение параметра в стек, мы ссылаемся 
            на переменную, которая находится в области вызова метода, передавшего параметр.

            Параметры передавать в метод можно двумя способами: по значению и по ссылке (с использованием ключевых слов in, out, ref).

             При передаче параметров по значению в фрейме метода выделяется память для переданного параметра.

                * Если передаваемый параметр является значимым типом, его значение записывается в выделенную память и используется, пока 
                  не будет произведен выход из метода.
                * Если передаваемый параметр является ссылочным типом, в выделенную память записывается ссылка на объект в куче.

            Однако, если передавать параметр по ссылке, мы не записываем ни новую ссылку, ни значение параметра в стек, мы ссылаемся 
            на переменную, которая находится в области вызова метода, передавшего параметр.

            -----------------------------
            String
            -----------------------------
            String является ссылочным типом, а значит, он не хранится напрямую в стеке, только ссылка на него. И этим он очень похож 
            на массив символов типа char. В отличие от массива, мы можем получить значение всех элементов массива сразу, без обращения 
            к каждому из них. И в отличие от других ссылочных типов, тип string неизменяем. Данное свойство называется иммутабельностью, 
            оно устанавливает ограничения по изменению на строку.

            Вы не сможете изменить строку в памяти, вместо этого будет создана новая строка, и ссылка в переменной будет заменена.

                Так для чего же типу string такая уникальная структура? Такие действия позволяют достигать 
                большей производительности и безопасности.

            За счет передачи ссылки на область в куче вместо копирования целой строки в стек (при передаче параметров в метод) мы не 
            тратим время и память и просто храним ссылку. Также при передаче строки в методы мы защищены от переполнения памяти в стеке, 
            поскольку строки могут занимать куда больше места, чем ссылка на нее.

            А из-за ее неизменяемости обеспечивается правильная работа со строкой во всех местах, куда бы вы ее не передавали 
            (вам бы не хотелось изменить строку в одном методе и увидеть, что она меняется во всем приложении и ломает этим логику программы), 
            в том числе и при работе с многопоточностью (когда несколько разных источников пытаются получить доступ к одной строке в одно 
            и то же время), о чем мы поговорим позднее.

            -----------------------------
            Значение null
            -----------------------------

            Как мы упоминали ранее, для ссылочных типов значением по умолчанию является специальное значение null. Фактически оно 
            говорит об отсутствии значения как такового.

            Также ссылочным типам можно и присваивать значение null:

                    object o = null;
                    Human human = null;

            Но при работе с классами мы можем получить ошибку из-за попытки доступа к полю класса, когда в переменной находится null значение:

            Важно иметь это в виду при работе с классами. Чтобы избежать таких ошибок, следует проверять значения ссылочных типов на null:

                    Human human = null;

                    if (human != null)
                    {
	                     Console.WriteLine(human.age);
                     }

            Данное выражение можно сократить с помощью null-условного оператора (или оператора распространения null).
            Для этого следует добавить знак ? к объекту, который может быть равен null, и дальше продолжить использовать его поля:

                    Human human = null;
                    Console.WriteLine(human?.age)

            В случае, если human будет равен null, то и значение выражения human?.age будет равно null.

            Более это полезно при работе с большой вложенностью объектов. Пусть у нас есть такая структура классов:

        class Employee
        {
            public Department Department;
        }

        class Department
        {
            public Company Company;
        }

        class Company
        {
            public string Name;
        }

            Мы используем объект типа Employee и хотим получить название компании, в которой работает сотрудник. 
            Для этого нам нужно воспользоваться следующей записью:

                    employee.Department.Company.Name

            Но поскольку все классы ссылочного типа, нам нужно проверить их на null:

if (employee != null && employee.Department != null && employee.Department.Company != null)
{
	name = employee.Department.Company.Name;
}
            С использованием данного оператора мы можем существенно сократить занесение имени компании в переменную name:

                    Employee employee = new Employee();
                    string name = employee?.Department?.Company?.Name;

            В такой записи последовательно проверяется, равен ли объект employee и вложенные объекты значению null. Если же 
            на каком-то этапе один из объектов окажется равным null, то name будет иметь значение по умолчанию, то есть null.

                Также вам пригодится оператор null-объединения, или оператор ??. Данный оператор возвращает левый операнд, 
                если этот операнд не равен null, иначе — правый. При этом левый операнд должен принимать null.

            Посмотрим на примере:

                    object first = null;
                    object second = first ?? 100;

            В данном случае в переменной second будет храниться 100, поскольку first равен null, и оператор ?? вернёт значение правого операнда.

            Это же работает и с классами, например так

                    Human human = null;
                    Human newHuman = human ?? new Human("Дмитрий", 23);

            Но данный оператор нельзя применять со значимыми типами, поскольку они не могут хранить значение null. 
            То есть такой код выдаст ошибку компиляции:

                    int one = 1;
                    int two = one ?? 2;

            Задание 6.3.1
            Вам даны следующие классы:

class Company
{
	public string Type;
	public string Name;
}

class Department
{
	public Company Company;
	public City City;
}

class City
{
	public string Name;
}
            И экземпляр класса Department, полученный из метода GetCurrentDepartment (логика работы метода опущена):

class Program
{
	static void Main(string[] args)
	{
		var department = GetCurrentDepartment();
	}

	static Department GetCurrentDepartment()
	{
		// logic
	}
}
            Напишите такой код, который бы при типе компании, равному типу "Банк", и городе "Санкт-Петербург" выводил 
            в консоль сообщение "У банка ??? есть отделение в Санкт-Петербурге", где вместо "???" выводилось бы название компании.

            Если у компании нет названия, вместо него должно быть "Неизвестная компания".

            Ответ:
                    if (department?.Company?.Type == "Банк" && department?.City?.Name == "Санкт-Петербург")
                    {
                    	Console.WriteLine("У банка {0} есть отделение в Санкт-Петербурге", department?.Company?.Name ?? "Неизвестная компания");
                    }

            Задание 6.3.2
            Для класса Bus реализуйте метод PrintStatus, который будет сообщать о количестве пассажиров в автобусе, если они есть. Или сообщать, что автобус пуст.

class Bus
{
	public int? Load;

	public void PrintStatus()
	{

	}
}
            Используйте HasValue и Value.
            
                HasValue используется для проверки наличия значения у nullable-типов (Nullable<T>). Nullable-типы позволяют 
                переменным значимых типов (например, int, double, bool) принимать значение null, что полезно, например, для работы 
                с базами данных или отсутствующими данными.

                HasValue — это удобный способ проверить, содержит ли nullable-переменная значение.
                Всегда проверяйте HasValue перед использованием Value, чтобы избежать исключений.
                Nullable-типы полезны для работы с данными, которые могут отсутствовать.

                Nullable-типы (например, int?, bool?) могут содержать либо значение, либо null.
                Для получения значения используется свойство Value, но только если HasValue равно true.

                    public void PrintStatus()
                    {
	                if (Load.HasValue && Load>0)
	                    {
		                 Console.WriteLine("В авбтобусе {0} пассажиров", Load.Value);
	                    }
	                else
	                    {
		                 Console.WriteLine("Автобус пуст!");
	                    }
                    }

            Задание 6.3.3
            Почему тип string является ссылочным? Выберите правильные варианты:

                Это позволяет сэкономить время и память при передаче в методы
                Это исключает переполнение стека

            Задание 6.3.4 
            Распределите типы в две колонки.

            Можно присваивать null      Нельзя присваивать null

            object string int? bool?    int decimal double byte

            Обычно значимые типы (value types), такие как int, не могут быть null, но с использованием int? это становится возможным.

            */

            Data data = new Data { Name = "Запись", Length = 10, Version = 1, Array = new int[] { 15, 30 } };
            Obj obj = new Obj { Name = "Запись", IsAlive = false, Weight = 15 };

            //копии данных
            var datacopy = data;
            var objcopy = obj;

            //data - новые значения, datacopy - нет изменений для нессылочных данных, но для массива данные изменятся
            data.Name = "Значение";
            data.Length = 35;
            data.Version = 2;
            data.Array[0] = 3;

            //класс передается по ссыле, и поэтому и objcopy тоже изменится (в куче только 1 ссылка)
            obj.Name = "Кот";
            obj.IsAlive = true;
            obj.Weight = 3;

            //при создании нового объекта в куче новая ссылка на objcopy
            objcopy = new Obj { Name = obj.Name, IsAlive = obj.IsAlive, Weight = obj.Weight };

            //obj - изменится, а objcopy нет
            obj.Name = "Стол";
            obj.IsAlive = false;
            obj.Weight = 15;
        }
           struct Data
        {
            // Поля структуры
            public string Name;
            public int Length;
            public int Version;
            public int[] Array;
        }
        class Obj
        {
            // Поля класса
            public string Name;
            public bool IsAlive;
            public int Weight;
        }
    }
}
